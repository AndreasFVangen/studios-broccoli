"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const helper = require("./src/helper");
const mutation_1 = require("./src/type/mutation");
const metadata = require("./src/metadata");
require("reflect-metadata");
var models = {};
var schema = {};
var mutations = { name: 'Mutation', fields: {} };
var haveMutation = false;
var mutationsArray = [];
var entryQuery = '';
var object = {};
class item {
    constructor(decorator, target, key) {
        this.decorator = decorator;
        this.target = target;
        this.key = key;
        this.description = metadata.getDescription(this.target, this.key);
        this.nullable = metadata.getNullable(this.target, key);
        this.type = Reflect.getMetadata("design:type", this.target, this.key).name;
        switch (this.type) {
            case 'Function':
                this.required = metadata.getRequired(this.target, this.key);
                let temp = metadata.getReturn(this.target, this.key) || Reflect.getMetadata("design:returntype", this.target, this.key);
                this.returnType = temp && temp.name ? temp.name : temp;
                var paramType = Reflect.getMetadata("design:paramtypes", this.target, this.key);
                if (paramType)
                    this.params = helper.getArgs(target, key, paramType);
                break;
            case 'Array':
                this.returnType = metadata.getReturn(this.target, this.key) || Reflect.getMetadata("design:returntype", this.target, this.key).name;
                break;
            default:
        }
    }
}
class property {
    constructor(type, target) {
        this.target = target;
        this.type = type;
        this.name = target.name;
        this.description = metadata.getDescription(this.target);
    }
}
function buildSchema(entryPoint) {
    var obj = object[entryPoint];
    if (!obj)
        throw new Error(`${entryPoint} is not valid`);
    var property = obj.property;
    switch (property.type) {
        case 'objectType': {
            models[property.name] = new graphql_1.GraphQLObjectType({
                name: property.name,
                fields: {},
                description: property.description
            });
            for (let key in obj.items) {
                let item = obj.items[key];
                switch (item.type) {
                    case 'Function': {
                        let type = helper.getGraphQLType(item.returnType) || models[item.returnType];
                        if (!type) {
                            type = buildSchema(item.returnType);
                        }
                        if (item.decorator == 'list')
                            type = new graphql_1.GraphQLList(type);
                        if (!item.nullable)
                            type = new graphql_1.GraphQLNonNull(type);
                        var wrapFunction = function (_, data, context, fieldAST) {
                            data._context = context;
                            data._root = _;
                            data._fieldAST = fieldAST;
                            var paramsTemp = item.params.map(function (param) {
                                return data[param.name] ? data[param.name] : undefined;
                            });
                            return item.target[item.key].apply(_, paramsTemp);
                        };
                        models[property.name]._typeConfig.fields[key] = {
                            type: type,
                            resolve: wrapFunction,
                            description: item.description,
                            args: helper.convertArgsToGraphQL(item.params, item.required, null)
                        };
                        break;
                    }
                    default:
                        let type = helper.getGraphQLType(item.type) || models[item.type];
                        if (!type && item.decorator == 'list') {
                            type = helper.getGraphQLType(item.returnType) || models[item.returnType];
                        }
                        if (!type) {
                            type = buildSchema(item.type);
                        }
                        if (item.decorator == 'list')
                            type = new graphql_1.GraphQLList(type);
                        if (!item.nullable)
                            type = new graphql_1.GraphQLNonNull(type);
                        models[property.name]._typeConfig.fields[key] = {
                            type: type,
                            description: item.description,
                        };
                        break;
                }
            }
            break;
        }
        case 'inputType': {
            models[property.name] = new graphql_1.GraphQLInputObjectType({
                name: property.name,
                description: property.description,
                fields: {}
            });
            for (let key in obj.items) {
                let item = obj.items[key];
                switch (item.decorator) {
                    case 'list':
                        let type = helper.getGraphQLType(item.returnType) || models[item.returnType];
                        if (!type) {
                            type = buildSchema(item.returnType);
                        }
                        type = new graphql_1.GraphQLList(type);
                        if (!item.nullable)
                            type = new graphql_1.GraphQLNonNull(type);
                        models[property.name]._typeConfig.fields[key] = {
                            type: type,
                            description: item.description
                        };
                        break;
                    default:
                        let type2 = helper.getGraphQLType(item.type) || models[item.type];
                        if (!item.nullable)
                            type2 = new graphql_1.GraphQLNonNull(type2);
                        if (!type2) {
                            type2 = buildSchema(item.type);
                        }
                        models[property.name]._typeConfig.fields[key] = {
                            type: type2,
                            description: item.description,
                        };
                        break;
                }
            }
            break;
        }
        case 'scalarType': {
            var items = obj.items;
            let temp = { name: property.name };
            for (let key in obj.items) {
                temp[key] = obj.items[key].target[key];
            }
            models[property.name] = new graphql_1.GraphQLScalarType(temp);
            break;
        }
    }
    return models[property.name];
}
function objectType(target) {
    if (!object[target.name])
        object[target.name] = { items: {}, property: {} };
    object[target.name].property = new property('objectType', target);
}
exports.objectType = objectType;
function inputType(target) {
    if (!object[target.name])
        object[target.name] = { items: {}, property: {} };
    object[target.name].property = new property('inputType', target);
    buildSchema(target.name);
}
exports.inputType = inputType;
function field(target, key) {
    if (!object[target.constructor.name])
        object[target.constructor.name] = { items: {}, property: {} };
    var temp = new item('field', target, key);
    object[target.constructor.name].items[key] = temp;
}
exports.field = field;
function list(target, key) {
    if (!object[target.constructor.name])
        object[target.constructor.name] = { items: {}, property: {} };
    var temp = new item('list', target, key);
    object[target.constructor.name].items[key] = temp;
}
exports.list = list;
function scalarType(target) {
    if (!object[target.name])
        object[target.name] = { items: {}, property: {} };
    object[target.name].property = new property('scalarType', target);
}
exports.scalarType = scalarType;
var graphqlTs;
(function (graphqlTs) {
    function getSchema() {
        return schema;
    }
    graphqlTs.getSchema = getSchema;
    function init(query) {
        var queryObject = query;
        if (queryObject.constructor.name)
            entryQuery = queryObject.constructor.name;
        buildSchema(entryQuery);
        mutationsArray.forEach(function (item) {
            mutation_1.mutationProcess(item.target, item.key, models, mutations, models);
        });
        schema.query = models[entryQuery];
        if (haveMutation)
            schema.mutation = new graphql_1.GraphQLObjectType(mutations);
        schema = new graphql_1.GraphQLSchema(schema);
    }
    graphqlTs.init = init;
    function query(query) {
        return graphql_1.graphql(getSchema(), query);
    }
    graphqlTs.query = query;
})(graphqlTs = exports.graphqlTs || (exports.graphqlTs = {}));
function required(name) {
    return metadata.required(name);
}
exports.required = required;
function description(text) {
    return metadata.description(text);
}
exports.description = description;
function nullable(nullable) {
    return metadata.nullable(nullable);
}
exports.nullable = nullable;
function returnType(objectType) {
    var temp = objectType;
    return metadata.returnType(temp.name);
}
exports.returnType = returnType;
function mutation(target, key) {
    haveMutation = true;
    mutationsArray.push({
        target: target,
        key: key
    });
}
exports.mutation = mutation;
